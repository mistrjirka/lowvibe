{
    "type": "implement",
    "payload": {
        "description": "Implement dynamic programming solution for minimum manufacturing cost and fewest units",
        "tasks": [
            {
                "type": "create_file",
                "task_description": "Create main implementation file with input parsing and DP logic",
                "code": "import sys\nfrom collections import defaultdict\n\ndef parse_input(input_lines):\n    \"\"\"Parse input data into structured format.\"\"\"\n    T = input_lines[0].strip()\n    N, Dmax = map(int, input_lines[1].split())\n    \n    basic_units = []\n    for i in range(2, 2 + 2*N, 2):\n        cost = int(input_lines[i])\n        sequence = input_lines[i+1].strip()\n        basic_units.append((cost, sequence))\n    \n    return T, N, Dmax, basic_units\n\ndef can_match(target, pattern, max_deletions):\n    \"\"\"Check if pattern can match target substring with â‰¤ max_deletions.\"\"\"\n    i = j = 0\n    deletions = 0\n    len_target = len(target)\n    len_pattern = len(pattern)\n    \n    while i &lt; len_target and j &lt; len_pattern:\n        if target[i] == pattern[j]:\n            i += 1\n            j += 1\n        else:\n            deletions += 1\n            if deletions &gt; max_deletions:\n                return False, None\n            # Try skipping in pattern (deletion)\n    \n    # If we've matched the entire target but not the whole pattern\n    if i == len_target and j &lt; len_pattern:\n        return True, deletions\n    return False, None\n\ndef solve_dna_manufacturing(input_lines):\n    \"\"\"Main function to solve the DNA manufacturing problem.\"\"\"\n    T, N, Dmax, basic_units = parse_input(input_lines)\n    len_T = len(T)\n    \n    # DP table: dp[i] = {min_cost, min_units} for first i characters\n    dp = [(float('inf'), float('inf'))] * (len_T + 1)\n    dp[0] = (0, 0)  # Base case: empty string\n    \n    # Precompute possible matches for each position\n    match_info = [[] for _ in range(len_T)]\n    for i in range(len_T):\n        for cost, pattern in basic_units:\n            can_match_result, deletions = can_match(T[i:], pattern, Dmax)\n            if can_match_result and deletions is not None:\n                match_length = len(pattern) - deletions\n                match_info[i].append((cost, pattern, match_length))\n    \n    # Fill DP table\n    for i in range(1, len_T + 1):\n        current_cost, current_units = dp[i-1]  # Option to extend previous solution\n        \n        # Try all possible matches starting at position i-1\n        for cost, pattern, match_length in match_info[i-1]:\n            if i - match_length &gt;= 0:\n                prev_cost, prev_units = dp[i - match_length]\n                total_cost = prev_cost + cost + (len(pattern) - match_length)\n                total_units = prev_units + 1\n                \n                # Update DP state if better solution found\n                if (total_cost &lt; current_cost) or \\\n                   (total_cost == current_cost and total_units &lt; current_units):\n                    dp[i] = (total_cost, total_units)\n        \n    return dp[len_T]\n\ndef main():\n    \"\"\"Read input from file and print solution.\"\"\"\n    with open(sys.argv[1], 'r') as f:\n        lines = [line.strip() for line in f if line.strip()]\n    \n    P, U = solve_dna_manufacturing(lines)\n    print(f\"{P} {U}\")\n\nif __name__ == \"__main__\":\n    main()",
                "file": "dna_manufacturing.py"
            }
        ]
    }
}